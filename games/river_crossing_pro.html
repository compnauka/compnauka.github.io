import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { RefreshCw, Trophy, Ban } from 'lucide-react';

/**
 * @typedef {'green' | 'yellow'} PlayerColor
 * @typedef {0|1|2|3|4|5|6|7|8|9|10|11} BoardIndex
 */

// --- Константи ---

const INITIAL_BOARD = {
  0: 'green', 1: 'green', 2: 'green',
  3: null, 4: null, 5: null,
  6: null, 7: null, 8: null,
  9: 'yellow', 10: 'yellow', 11: 'yellow'
};

// Граф переходів
const MOVES = {
  0: [1, 3], 1: [0, 2, 4], 2: [1, 5],
  3: [0, 4], 4: [1, 3, 5, 7], 5: [2, 4],
  6: [7, 9], 7: [4, 6, 8, 10], 8: [7, 11],
  9: [6, 10], 10: [7, 9, 11], 11: [8, 10]
};

// Позиції рядків у відсотках (Top, Top-Bank, Bottom-Bank, Bottom)
const ROW_POSITIONS = [0, 35, 65, 100];

export default function CrossingGame() {
  const [board, setBoard] = useState(INITIAL_BOARD);
  const [turn, setTurn] = useState('green');
  const [selectedPiece, setSelectedPiece] = useState(null);
  const [winner, setWinner] = useState(null); // 'green', 'yellow', 'green_blocked', 'yellow_blocked'
  const [showResetModal, setShowResetModal] = useState(false);

  // --- Логіка гри ---

  // Перевірка наявності доступних ходів для гравця
  const hasAvailableMoves = useCallback((playerColor, currentBoard) => {
    // Знаходимо всі фігури поточного гравця
    const playerPieces = Object.keys(currentBoard)
      .map(Number)
      .filter(key => currentBoard[key] === playerColor);

    // Перевіряємо, чи хоча б одна фігура має вільну сусідню клітинку
    return playerPieces.some(pieceIndex => 
      MOVES[pieceIndex].some(targetIndex => currentBoard[targetIndex] === null)
    );
  }, []);

  // Перевірка стану гри (перемога або блокування)
  useEffect(() => {
    const checkGameState = () => {
      // 1. Пряма перемога (зайняли базу)
      const greenWin = board[9] === 'green' && board[10] === 'green' && board[11] === 'green';
      const yellowWin = board[0] === 'yellow' && board[1] === 'yellow' && board[2] === 'yellow';

      if (greenWin) { setWinner('green'); return; }
      if (yellowWin) { setWinner('yellow'); return; }

      // 2. Перевірка на блокування (якщо ходити нікуди - програв той, чий хід)
      if (!hasAvailableMoves(turn, board)) {
        // Якщо поточному гравцю нікуди ходити, перемагає суперник
        setWinner(turn === 'green' ? 'yellow_blocked' : 'green_blocked');
      }
    };

    checkGameState();
  }, [board, turn, hasAvailableMoves]);

  const handlePointClick = (index) => {
    if (winner) return;

    const content = board[index];
    const isCurrentTurnPiece = content === turn;
    const isEmpty = content === null;

    // Сценарій 1: Вибір своєї фігури (або зміна вибору)
    if (isCurrentTurnPiece) {
      setSelectedPiece(index);
      return;
    }

    // Сценарій 2: Хід на порожню клітинку
    if (isEmpty && selectedPiece !== null) {
      if (MOVES[selectedPiece].includes(index)) {
        // Виконуємо хід
        const newBoard = { ...board };
        newBoard[index] = turn;
        newBoard[selectedPiece] = null;
        
        setBoard(newBoard);
        setTurn(prev => prev === 'green' ? 'yellow' : 'green');
        setSelectedPiece(null);
      } else {
        // Клік на недоступну клітинку - скидаємо виділення
        setSelectedPiece(null);
      }
      return;
    }

    // Сценарій 3: Клік на чужу фігуру або щось інше - скидаємо
    setSelectedPiece(null);
  };

  const confirmReset = () => {
    setBoard(INITIAL_BOARD);
    setTurn('green');
    setSelectedPiece(null);
    setWinner(null);
    setShowResetModal(false);
  };

  // Оптимізований розрахунок позицій
  const pointPositions = useMemo(() => {
    const positions = {};
    for (let i = 0; i <= 11; i++) {
      const localRow = Math.floor(i / 3); // 0, 1, 2, 3
      const col = i % 3;
      const topPct = ROW_POSITIONS[localRow];
      positions[i] = { top: `${topPct}%`, left: `${col * 50}%` };
    }
    return positions;
  }, []);

  return (
    <div className="min-h-screen bg-slate-50 flex flex-col items-center justify-center p-4 font-sans text-slate-800 select-none touch-none">
      
      <header className="mb-6 text-center z-10">
        <h1 className="text-3xl font-extrabold mb-2 text-slate-900 tracking-tight">Переправа</h1>
        <p className="text-sm text-slate-600 font-medium bg-white/60 px-4 py-1.5 rounded-full backdrop-blur-sm border border-slate-100 shadow-sm inline-block">
          Перенеси свої фішки на протилежний бік.
        </p>
      </header>

      {/* Основний контейнер: покращена адаптивність */}
      <div className="relative p-6 md:p-10 bg-white shadow-2xl rounded-2xl border border-slate-100 w-full max-w-[min(400px,90vw)] transition-all duration-300">
        
        {/* Індикатори */}
        <div className="absolute -top-5 left-0 right-0 flex justify-center gap-3">
           <TurnIndicator player="green" currentTurn={turn} />
           <TurnIndicator player="yellow" currentTurn={turn} />
        </div>

        {/* Екран перемоги */}
        {winner && (
            <div className="absolute inset-0 z-50 bg-white/95 backdrop-blur-md rounded-2xl flex flex-col items-center justify-center p-6 animate-in fade-in zoom-in duration-300 text-center">
              {winner.includes('blocked') ? (
                <Ban className="w-16 h-16 text-red-500 mb-4" />
              ) : (
                <Trophy className="w-16 h-16 text-amber-500 mb-4" />
              )}
              
              <div className="text-2xl font-black text-slate-800 mb-2">
                {winner.startsWith('green') ? 'Зелені' : 'Жовті'} перемогли!
              </div>
              
              {winner.includes('blocked') && (
                <div className="text-sm text-red-500 font-medium mb-6 bg-red-50 px-3 py-1 rounded-lg">
                  Суперника заблоковано
                </div>
              )}

              <button 
                onClick={confirmReset}
                className="w-full py-3 bg-slate-900 text-white font-bold rounded-xl hover:bg-slate-800 active:scale-95 transition-all shadow-lg"
              >
                Нова гра
              </button>
            </div>
        )}

        {/* Ігрове поле */}
        <div className="relative w-full aspect-[224/384] max-w-[260px] mx-auto my-2">
          <BoardLines />
          
          {/* Рендеринг точок */}
          {[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map((index) => {
            const pos = pointPositions[index];
            const canMoveTo = selectedPiece !== null && board[index] === null && MOVES[selectedPiece].includes(index);
            const isSelected = selectedPiece === index;
            const hasPiece = board[index] !== null;

            return (
              <div
                key={index}
                onClick={() => handlePointClick(index)}
                style={{ top: pos.top, left: pos.left }}
                className={`
                  absolute w-14 h-14 md:w-16 md:h-16 -translate-x-1/2 -translate-y-1/2
                  flex items-center justify-center cursor-pointer z-20 rounded-full
                  ${!hasPiece && !canMoveTo ? 'tap-highlight-transparent' : ''} 
                  active:scale-95 transition-transform duration-100
                `}
                role="button"
                aria-label={`Клітинка ${index}`}
              >
                {/* Маркер ходу */}
                {canMoveTo && (
                   <div className="w-5 h-5 bg-blue-500/80 rounded-full shadow-[0_0_15px_rgba(59,130,246,0.6)] animate-pulse ring-4 ring-white/60"></div>
                )}
                
                {/* Фігура */}
                {hasPiece && (
                  <Piece 
                    color={board[index]} 
                    isSelected={isSelected} 
                    isWinner={!!winner} 
                  />
                )}
              </div>
            );
          })}
        </div>
      </div>

      <div className="mt-8">
        <button 
          onClick={() => setShowResetModal(true)}
          className="flex items-center gap-2 px-6 py-3 text-slate-500 font-semibold hover:text-slate-900 hover:bg-white rounded-full transition-all shadow-sm active:scale-95 border border-transparent hover:border-slate-200 bg-white/50"
        >
          <RefreshCw size={18} />
          <span>Скинути</span>
        </button>
      </div>

      {/* Модал підтвердження */}
      {showResetModal && (
        <div className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-slate-900/40 backdrop-blur-sm animate-in fade-in duration-200">
          <div className="bg-white rounded-2xl shadow-2xl p-6 w-full max-w-xs transform scale-100 animate-in zoom-in-95 duration-200">
            <h3 className="text-lg font-bold text-slate-900 mb-2">Перезапуск</h3>
            <p className="text-slate-500 text-sm mb-6">Прогрес буде втрачено. Впевнені?</p>
            <div className="flex gap-3">
              <button 
                onClick={() => setShowResetModal(false)}
                className="flex-1 py-2 px-4 rounded-xl font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 transition-colors text-sm"
              >
                Скасувати
              </button>
              <button 
                onClick={confirmReset}
                className="flex-1 py-2 px-4 rounded-xl font-medium text-white bg-slate-900 hover:bg-slate-800 transition-colors shadow-md text-sm"
              >
                Так
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// --- Компоненти UI ---

const TurnIndicator = ({ player, currentTurn }) => {
  const isActive = currentTurn === player;
  const isGreen = player === 'green';
  
  // Виправлено: повні імена класів для Tailwind
  const activeClasses = isActive 
    ? `bg-white scale-105 ${isGreen ? 'border-green-500 ring-green-100' : 'border-yellow-400 ring-yellow-100'} ring-2` 
    : 'border-slate-200 bg-slate-50 opacity-50 grayscale';

  return (
    <div className={`
      flex items-center gap-2 px-4 py-2 rounded-full shadow-sm transition-all duration-300 border
      ${activeClasses}
    `}>
      {isGreen && <div className="w-3 h-3 bg-green-500 rounded-sm shadow-sm"></div>}
      <span className="font-bold text-sm text-slate-700">{isGreen ? 'Зелені' : 'Жовті'}</span>
      {!isGreen && <div className="w-3 h-3 bg-yellow-400 rounded-sm shadow-sm"></div>}
    </div>
  );
};

const Piece = ({ color, isSelected, isWinner }) => {
  const isGreen = color === 'green';
  
  // Виправлено: повні імена класів для Tailwind
  const colorClasses = isGreen 
    ? 'bg-green-500 border-green-600' 
    : 'bg-yellow-400 border-yellow-500';

  return (
    <div className={`
      relative w-11 h-11 md:w-12 md:h-12 rounded-lg shadow-sm
      flex items-center justify-center transition-all duration-200
      border-2 
      ${colorClasses}
      ${isSelected ? '-translate-y-2 scale-110 ring-4 ring-blue-300 z-30 shadow-lg' : 'hover:-translate-y-0.5 shadow-md'}
      ${isWinner ? 'opacity-50 grayscale' : ''}
    `}>
       <div className={`w-6 h-6 rounded-full opacity-20 ${isGreen ? 'bg-green-900' : 'bg-yellow-800'}`}></div>
       <div className="absolute top-1 left-1 w-2 h-2 bg-white/30 rounded-full"></div>
    </div>
  );
};

const BoardLines = () => (
  <div className="absolute inset-0 pointer-events-none opacity-90">
    <div className="absolute top-0 h-[35%] left-0 right-0 border-4 border-slate-800 rounded-sm"></div>
    <div className="absolute top-0 h-[35%] left-1/2 w-1 bg-slate-800 -translate-x-1/2"></div>
    
    <div className="absolute bottom-0 h-[35%] left-0 right-0 border-4 border-slate-800 rounded-sm"></div>
    <div className="absolute bottom-0 h-[35%] left-1/2 w-1 bg-slate-800 -translate-x-1/2"></div>

    {/* Міст */}
    <div className="absolute top-[35%] bottom-[35%] left-1/2 w-[6px] bg-slate-800 -translate-x-1/2 rounded-full z-0"></div>
    
    {/* Вода */}
    <div className="absolute top-[35%] bottom-[35%] left-0 right-0 bg-blue-100/40 -z-10 flex items-center justify-center border-y border-blue-200/50">
        <span className="text-blue-300/80 text-[10px] tracking-[0.4em] font-black uppercase -rotate-90 md:rotate-0 select-none">
          Річка
        </span>
    </div>
  </div>
);
