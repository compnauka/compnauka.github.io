<!DOCTYPE html>
<html lang="uk">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Онлайн-дошка</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-N8T05K3NGT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-N8T05K3NGT');
  </script>

  <meta name="theme-color" content="#111827" />
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #ffffff;
      color: #111827;
      position: fixed;
      width: 100%;
      height: 100%;
      overscroll-behavior: none;
    }

    /* Сітка */
    #app {
      background-image: radial-gradient(#e5e7eb 1px, transparent 1px);
      background-size: 20px 20px;
    }

    #whiteboard {
      touch-action: none;
      -webkit-touch-callout: none;
    }

    .tool-btn {
      transition: all 0.15s ease;
    }

    .tool-btn[aria-pressed="true"] {
      transform: scale(1.05);
      background-color: #dbeafe;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.6);
    }

    .color-btn[aria-current="true"] {
      transform: scale(1.1);
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.6);
      border-color: transparent;
    }

    .modal-backdrop {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(2px);
    }

    .toolbar-responsive {
      max-width: 98vw;
      transition: opacity 0.3s;
    }

    @media (max-width: 1100px) {
      .toolbar-responsive {
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
        padding: 0.5rem;
        width: 95%;
        border-radius: 1rem;
      }

      .separator {
        display: none;
      }
    }
  </style>
</head>

<body class="h-screen w-screen overflow-hidden">
  <div id="app" class="relative w-full h-full">

    <canvas id="whiteboard" class="block w-full h-full cursor-crosshair select-none touch-none"></canvas>

    <!-- Timer Overlay -->
    <div id="timer-overlay"
      class="hidden absolute top-4 right-4 z-30 bg-gray-900/95 text-white text-2xl font-mono px-6 py-3 rounded-lg shadow-xl tabular-nums tracking-wider pointer-events-none select-none">
      <span id="timer-display">00:00</span>
    </div>

    <!-- Toolbar -->
    <div
      class="toolbar-responsive absolute bottom-6 left-1/2 -translate-x-1/2 z-40 bg-white/95 backdrop-blur shadow-xl border border-gray-200 rounded-2xl p-2 flex items-center gap-3">

      <!-- Tools -->
      <div class="flex items-center gap-1 bg-gray-100/50 p-1 rounded-lg">
        <button id="btn-pen"
          class="tool-btn w-10 h-10 rounded-md flex items-center justify-center text-gray-700 hover:bg-gray-200"
          data-tool="pen" aria-pressed="true" title="Перо">
          <i class="fa-solid fa-pen"></i>
        </button>
        <button id="btn-eraser"
          class="tool-btn w-10 h-10 rounded-md flex items-center justify-center text-gray-700 hover:bg-gray-200"
          data-tool="eraser" aria-pressed="false" title="Гумка">
          <i class="fa-solid fa-eraser"></i>
        </button>
      </div>

      <div class="separator w-px h-8 bg-gray-300"></div>

      <!-- Colors -->
      <div class="flex items-center gap-2">
        <div class="relative group w-8 h-8">
          <input id="color-picker" type="color" value="#000000"
            class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
          <div class="w-full h-full rounded-full border-2 border-gray-300 shadow-sm"
            style="background:conic-gradient(red, yellow, lime, aqua, blue, magenta, red)"></div>
        </div>
        <div class="flex items-center gap-1.5">
          <button class="color-btn w-6 h-6 rounded border border-gray-300 bg-black" data-color="#000000"
            aria-current="true"></button>
          <button class="color-btn w-6 h-6 rounded border border-gray-300 bg-red-500" data-color="#ef4444"></button>
          <button class="color-btn w-6 h-6 rounded border border-gray-300 bg-blue-500" data-color="#3b82f6"></button>
        </div>
      </div>

      <!-- Size -->
      <div class="flex items-center gap-2 bg-gray-100 p-2 rounded-lg">
        <i class="fa-solid fa-circle text-[6px] text-gray-400"></i>
        <input id="size-range" type="range" min="2" max="40" value="4" class="w-20 cursor-pointer accent-blue-600">
        <i class="fa-solid fa-circle text-lg text-gray-400"></i>
      </div>

      <div class="separator w-px h-8 bg-gray-300"></div>

      <!-- Actions -->
      <div class="flex items-center gap-1">
        <button id="btn-undo"
          class="tool-btn w-10 h-10 rounded-lg hover:bg-gray-100 disabled:opacity-30 disabled:cursor-not-allowed text-gray-700"
          disabled title="Скасувати">
          <i class="fa-solid fa-rotate-left"></i>
        </button>
        <button id="btn-redo"
          class="tool-btn w-10 h-10 rounded-lg hover:bg-gray-100 disabled:opacity-30 disabled:cursor-not-allowed text-gray-700"
          disabled title="Повторити">
          <i class="fa-solid fa-rotate-right"></i>
        </button>
        <button id="btn-clear" class="tool-btn w-10 h-10 rounded-lg text-red-600 hover:bg-red-50" title="Очистити">
          <i class="fa-solid fa-trash-can"></i>
        </button>
      </div>

      <div class="separator w-px h-8 bg-gray-300"></div>

      <div class="flex items-center gap-1">
        <!-- SVG Export Button -->
        <button id="btn-svg" class="tool-btn w-10 h-10 rounded-lg text-orange-600 hover:bg-orange-50"
          title="Експорт SVG">
          <i class="fa-solid fa-file-code"></i>
        </button>
        <button id="btn-save" class="tool-btn w-10 h-10 rounded-lg text-green-700 hover:bg-green-50"
          title="Завантажити PNG">
          <i class="fa-solid fa-download"></i>
        </button>
        <button id="btn-qr" class="tool-btn w-10 h-10 rounded-lg text-purple-700 hover:bg-purple-50" title="QR код">
          <i class="fa-solid fa-qrcode"></i>
        </button>
        <button id="btn-timer" class="tool-btn w-10 h-10 rounded-lg text-yellow-600 hover:bg-yellow-50" title="Таймер">
          <i class="fa-solid fa-stopwatch"></i>
        </button>
      </div>
    </div>

    <!-- Modals -->
    <div id="dlg-clear" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
      <div class="bg-white rounded-xl shadow-2xl p-6 w-80 transform transition-all">
        <h3 class="text-lg font-bold mb-2 text-gray-900">Очистити дошку?</h3>
        <p class="text-gray-500 text-sm mb-6">Всі малюнки буде видалено безповоротно.</p>
        <div class="flex justify-end gap-3">
          <button data-close
            class="px-4 py-2 rounded-lg hover:bg-gray-100 text-gray-700 font-medium transition-colors">Скасувати</button>
          <button id="confirm-clear"
            class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-medium transition-colors shadow-sm">Очистити</button>
        </div>
      </div>
    </div>

    <!-- QR Modal (Small) -->
    <div id="dlg-qr" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
      <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md mx-4">
        <div class="flex justify-between items-center mb-4">
          <h3 class="font-bold text-lg text-gray-900">QR Генератор</h3>
          <button data-close class="text-gray-400 hover:text-gray-900 text-2xl transition-colors">&times;</button>
        </div>
        <input id="qr-input" type="text" placeholder="URL або текст"
          class="w-full border border-gray-300 p-2.5 rounded-lg mb-4 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition-all">

        <!-- Output container, clickable -->
        <div id="qr-output"
          class="flex justify-center bg-gray-50 p-6 rounded-lg min-h-[180px] items-center border border-dashed border-gray-300 transition-colors hover:bg-gray-100"
          title="Натисніть для збільшення">
          <span class="text-gray-400 text-sm">QR код з'явиться тут</span>
        </div>

        <button id="qr-gen-btn"
          class="w-full mt-4 bg-blue-600 text-white py-2.5 rounded-lg hover:bg-blue-700 font-medium transition-colors shadow-sm">Згенерувати</button>
      </div>
    </div>

    <!-- QR Modal (Zoomed) -->
    <div id="dlg-qr-zoom"
      class="hidden fixed inset-0 z-[60] bg-white flex flex-col items-center justify-center cursor-zoom-out">
      <div id="qr-zoom-content" class="p-4 bg-white"></div>
      <div class="absolute bottom-10 text-gray-500 font-medium animate-pulse">Натисніть будь-де, щоб закрити</div>
    </div>

    <div id="dlg-timer" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
      <div class="bg-white rounded-xl shadow-2xl p-6 w-80">
        <div class="flex justify-between items-center mb-4">
          <h3 class="font-bold text-lg text-gray-900">Таймер</h3>
          <button data-close class="text-gray-400 hover:text-gray-900 text-2xl transition-colors">&times;</button>
        </div>
        <div class="flex justify-center gap-2 items-center mb-6">
          <input id="tm-min" type="number" min="0" max="99" value="5"
            class="w-20 text-center text-3xl font-mono border border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none">
          <span class="text-2xl font-bold text-gray-400">:</span>
          <input id="tm-sec" type="number" min="0" max="59" value="0"
            class="w-20 text-center text-3xl font-mono border border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none">
        </div>
        <div class="grid grid-cols-2 gap-3">
          <button id="tm-action-btn"
            class="bg-green-600 text-white py-2.5 rounded-lg hover:bg-green-700 font-medium col-span-2 transition-colors shadow-sm">Старт</button>
          <button id="tm-reset-btn"
            class="bg-gray-100 text-gray-700 py-2.5 rounded-lg hover:bg-gray-200 font-medium col-span-2 transition-colors">Скинути</button>
        </div>
      </div>
    </div>

  </div>

  <script>
    const $ = (s) => document.querySelector(s);
    const $$ = (s) => document.querySelectorAll(s);

    class Whiteboard {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { desynchronized: true, alpha: true });
        this.dpr = Math.max(1, window.devicePixelRatio || 1);

        this.tool = 'pen';
        this.color = '#000000';
        this.size = 4;

        this.strokes = [];
        this.redoStack = [];
        this.isDrawing = false;
        this.currentPoints = [];

        this.STORAGE_KEY = 'whiteboard_data';
        this.resizeDebounce = null;

        this.init();
      }

      init() {
        this.loadFromStorage();
        this.setupDimensions();

        window.addEventListener('resize', () => {
          clearTimeout(this.resizeDebounce);
          this.resizeDebounce = setTimeout(() => this.resize(), 100);
        });

        this.canvas.addEventListener('pointerdown', this.onDown.bind(this));
        this.canvas.addEventListener('pointermove', this.onMove.bind(this));
        this.canvas.addEventListener('pointerup', this.onUp.bind(this));
        this.canvas.addEventListener('pointercancel', this.onUp.bind(this));
        this.canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

        // Попередження при закритті вкладки
        window.addEventListener('beforeunload', (e) => {
          if (this.strokes.length > 0) {
            e.preventDefault();
            e.returnValue = '';
          }
        });
      }

      setupDimensions() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width * this.dpr;
        this.canvas.height = rect.height * this.dpr;

        this.ctx.scale(this.dpr, this.dpr);
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
      }

      resize() {
        this.setupDimensions();
        this.redraw();
      }

      onDown(e) {
        if (e.pointerType === 'mouse' && e.button !== 0) return;
        e.preventDefault();
        this.canvas.setPointerCapture(e.pointerId);
        this.isDrawing = true;

        const pos = this.getPos(e);
        this.currentPoints = [pos];
        this.drawPath([pos, pos], { tool: this.tool, color: this.color, size: this.size });
      }

      onMove(e) {
        if (!this.isDrawing) return;

        let events = [e];
        if (e.getCoalescedEvents && e.getCoalescedEvents().length > 0) {
          events = e.getCoalescedEvents();
        }

        const newPoints = [];
        events.forEach(evt => {
          const p = this.getPos(evt);
          const last = this.currentPoints[this.currentPoints.length - 1];

          // Оптимізація: фільтруємо точки, що надто близько (менше 2px)
          const dx = p.x - last.x;
          const dy = p.y - last.y;
          if (dx * dx + dy * dy > 4) {
            newPoints.push(p);
          }
        });

        if (newPoints.length === 0) return;

        const lastPoint = this.currentPoints[this.currentPoints.length - 1];
        const path = [lastPoint, ...newPoints];

        this.drawPath(path, { tool: this.tool, color: this.color, size: this.size });
        this.currentPoints.push(...newPoints);
      }

      onUp(e) {
        if (!this.isDrawing) return;
        this.isDrawing = false;
        try { this.canvas.releasePointerCapture(e.pointerId); } catch (err) { }

        if (this.currentPoints.length > 0) {
          this.strokes.push({
            tool: this.tool,
            color: this.color,
            size: this.size,
            points: [...this.currentPoints]
          });
          this.redoStack = [];
          this.saveToStorage();
          this.triggerUpdate();
        }
        this.currentPoints = [];
      }

      getPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
      }

      setContextState(config) {
        this.ctx.lineWidth = config.size;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        if (config.tool === 'eraser') {
          this.ctx.globalCompositeOperation = 'destination-out';
          this.ctx.strokeStyle = '#000000';
        } else {
          this.ctx.globalCompositeOperation = 'source-over';
          this.ctx.strokeStyle = config.color;
        }
      }

      drawPath(points, config) {
        if (points.length < 1) return;

        this.ctx.beginPath();
        this.setContextState(config);

        this.ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          this.ctx.lineTo(points[i].x, points[i].y);
        }
        this.ctx.stroke();
      }

      redraw() {
        // Очищення через скидання трансформації на Identity (1,0,0,1,0,0)
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Відновлюємо scale для подальшого малювання
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

        this.strokes.forEach(stroke => {
          const pts = stroke.points.length === 1 ? [stroke.points[0], stroke.points[0]] : stroke.points;
          this.drawPath(pts, stroke);
        });
      }

      // --- Збереження / Завантаження ---

      saveToStorage() {
        try {
          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.strokes));
        } catch (e) { console.warn('Storage quota exceeded'); }
      }

      loadFromStorage() {
        try {
          const data = localStorage.getItem(this.STORAGE_KEY);
          if (data) {
            this.strokes = JSON.parse(data);
            this.triggerUpdate();
          }
        } catch (e) { }
      }

      undo() {
        if (this.strokes.length) {
          this.redoStack.push(this.strokes.pop());
          this.redraw();
          this.saveToStorage();
          this.triggerUpdate();
        }
      }

      redo() {
        if (this.redoStack.length) {
          this.strokes.push(this.redoStack.pop());
          this.redraw();
          this.saveToStorage();
          this.triggerUpdate();
        }
      }

      clear() {
        this.strokes = [];
        this.redoStack = [];
        this.redraw();
        this.saveToStorage();
        this.triggerUpdate();
      }

      triggerUpdate() {
        window.dispatchEvent(new CustomEvent('board:state', {
          detail: {
            canUndo: this.strokes.length > 0,
            canRedo: this.redoStack.length > 0
          }
        }));
      }

      downloadPNG() {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;
        const tCtx = tempCanvas.getContext('2d');

        tCtx.fillStyle = '#ffffff';
        tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        tCtx.drawImage(this.canvas, 0, 0);

        const link = document.createElement('a');
        link.download = `whiteboard-${Date.now()}.png`;
        link.href = tempCanvas.toDataURL();
        link.click();
      }

      downloadSVG() {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`;
        svg += `<rect width="100%" height="100%" fill="white"/>`;

        this.strokes.forEach(s => {
          // Для гумки в SVG малюємо білим кольором
          const color = s.tool === 'eraser' ? '#ffffff' : s.color;
          const width = s.size;

          if (s.points.length > 0) {
            let d = `M ${s.points[0].x} ${s.points[0].y}`;
            for (let i = 1; i < s.points.length; i++) {
              d += ` L ${s.points[i].x} ${s.points[i].y}`;
            }
            // Додаємо лінію нульової довжини для точок
            if (s.points.length === 1) d += ` L ${s.points[0].x} ${s.points[0].y}`;

            svg += `<path d="${d}" stroke="${color}" stroke-width="${width}" fill="none" stroke-linecap="round" stroke-linejoin="round"/>`;
          }
        });
        svg += `</svg>`;

        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `whiteboard-${Date.now()}.svg`;
        link.click();
      }
    }

    class Timer {
      constructor() {
        this.remaining = 0;
        this.interval = null;
        this.isRunning = false;
        this.audioCtx = null;

        this.els = {
          overlay: $('#timer-overlay'),
          display: $('#timer-display'),
          modal: $('#dlg-timer'),
          min: $('#tm-min'),
          sec: $('#tm-sec'),
          actionBtn: $('#tm-action-btn')
        };
      }

      initAudio() {
        if (!this.audioCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          this.audioCtx = new AC();
        }
        if (this.audioCtx.state === 'suspended') {
          this.audioCtx.resume().catch(() => { });
        }
      }

      toggle() {
        this.initAudio();
        this.isRunning ? this.pause() : this.start();
      }

      start() {
        if (this.remaining === 0) {
          const m = Math.abs(parseInt(this.els.min.value) || 0);
          const s = Math.abs(parseInt(this.els.sec.value) || 0);
          this.remaining = m * 60 + s;
        }

        if (this.remaining <= 0) return;

        this.els.modal.classList.add('hidden');
        this.els.overlay.classList.remove('hidden');

        this.isRunning = true;
        this.updateBtnState(true);
        this.render();

        this.interval = setInterval(() => {
          this.remaining--;
          this.render();
          if (this.remaining <= 0) {
            this.finish();
          }
        }, 1000);
      }

      pause() {
        clearInterval(this.interval);
        this.isRunning = false;
        this.updateBtnState(false);
      }

      reset() {
        this.pause();
        this.remaining = 0;
        this.els.overlay.classList.add('hidden');
        this.els.actionBtn.textContent = "Старт";
        this.els.actionBtn.className = "bg-green-600 text-white py-2.5 rounded-lg hover:bg-green-700 font-medium col-span-2 transition-colors shadow-sm";
      }

      finish() {
        this.reset();
        this.beep();
        if ('vibrate' in navigator) {
          try { navigator.vibrate([200, 100, 200]); } catch (e) { }
        }
      }

      updateBtnState(isRunning) {
        if (isRunning) {
          this.els.actionBtn.textContent = "Пауза";
          this.els.actionBtn.className = "bg-yellow-500 text-white py-2.5 rounded-lg hover:bg-yellow-600 font-medium col-span-2 transition-colors shadow-sm";
        } else {
          this.els.actionBtn.textContent = "Продовжити";
          this.els.actionBtn.className = "bg-green-600 text-white py-2.5 rounded-lg hover:bg-green-700 font-medium col-span-2 transition-colors shadow-sm";
        }
      }

      render() {
        const m = Math.floor(this.remaining / 60).toString().padStart(2, '0');
        const s = (this.remaining % 60).toString().padStart(2, '0');
        this.els.display.textContent = `${m}:${s}`;
      }

      beep() {
        if (!this.audioCtx) return;
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(523.25, this.audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(880, this.audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.3, this.audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audioCtx.currentTime + 0.5);
        osc.start();
        osc.stop(this.audioCtx.currentTime + 0.5);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const board = new Whiteboard($('#whiteboard'));
      const timer = new Timer();

      $$('.tool-btn[data-tool]').forEach(btn => {
        btn.addEventListener('click', () => {
          board.tool = btn.dataset.tool;
          $$('.tool-btn[data-tool]').forEach(b => b.setAttribute('aria-pressed', b === btn));
        });
      });

      const updateColor = (color) => {
        board.color = color;
        $('#color-picker').value = color;
        if (board.tool === 'eraser') {
          board.tool = 'pen';
          $('[data-tool="pen"]').click();
        }
        $$('.color-btn').forEach(b => {
          b.setAttribute('aria-current', b.dataset.color === color ? 'true' : 'false');
        });
      };

      $$('.color-btn').forEach(btn => {
        btn.addEventListener('click', () => updateColor(btn.dataset.color));
      });

      $('#color-picker').addEventListener('input', (e) => {
        updateColor(e.target.value);
        $$('.color-btn').forEach(b => b.setAttribute('aria-current', 'false'));
      });

      $('#size-range').addEventListener('input', (e) => {
        board.size = parseInt(e.target.value);
      });

      $('#btn-undo').addEventListener('click', () => board.undo());
      $('#btn-redo').addEventListener('click', () => board.redo());
      $('#btn-save').addEventListener('click', () => board.downloadPNG());
      $('#btn-svg').addEventListener('click', () => board.downloadSVG());

      window.addEventListener('board:state', (e) => {
        $('#btn-undo').disabled = !e.detail.canUndo;
        $('#btn-redo').disabled = !e.detail.canRedo;
      });

      const toggleModal = (id, show) => {
        const el = $(id);
        if (show) {
          el.classList.remove('hidden');
          const input = el.querySelector('input');
          if (input) setTimeout(() => input.focus(), 50);
        } else {
          el.classList.add('hidden');
        }
      };

      $$('[data-close]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          toggleModal('#' + e.target.closest('.modal-backdrop').id, false);
        });
      });

      $('#btn-clear').addEventListener('click', () => toggleModal('#dlg-clear', true));
      $('#confirm-clear').addEventListener('click', () => {
        board.clear();
        toggleModal('#dlg-clear', false);
      });

      $('#btn-qr').addEventListener('click', () => {
        $('#qr-input').value = window.location.href;
        $('#qr-output').innerHTML = '<span class="text-gray-400 text-sm">Натисніть "Згенерувати"</span>';
        // Reset click handlers or visual cues if needed
        $('#qr-output').dataset.val = "";
        $('#qr-output').classList.remove('cursor-pointer', 'hover:bg-gray-100');
        $('#qr-output').title = "";
        toggleModal('#dlg-qr', true);
      });

      $('#qr-gen-btn').addEventListener('click', () => {
        const val = $('#qr-input').value || window.location.href;
        const out = $('#qr-output');
        out.innerHTML = '';
        if (window.QRCode) {
          new QRCode(out, { text: val, width: 150, height: 150, correctLevel: QRCode.CorrectLevel.M });
          // Make clickable for zoom
          out.dataset.val = val;
          out.classList.add('cursor-pointer', 'hover:bg-gray-100');
          out.title = "Натисніть для збільшення";
        } else {
          out.textContent = "Помилка завантаження бібліотеки";
        }
      });

      // Click handler for small QR code to trigger zoom
      $('#qr-output').addEventListener('click', () => {
        const val = $('#qr-output').dataset.val;
        if (!val) return;

        const zoomDlg = $('#dlg-qr-zoom');
        const zoomContent = $('#qr-zoom-content');

        zoomContent.innerHTML = '';
        // 80% of smallest screen dimension
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.8;

        if (window.QRCode) {
          new QRCode(zoomContent, { text: val, width: size, height: size, correctLevel: QRCode.CorrectLevel.H });
          zoomDlg.classList.remove('hidden');
        }
      });

      // Close zoom overlay on click
      $('#dlg-qr-zoom').addEventListener('click', () => {
        $('#dlg-qr-zoom').classList.add('hidden');
      });

      $('#btn-timer').addEventListener('click', () => toggleModal('#dlg-timer', true));
      $('#tm-action-btn').addEventListener('click', () => timer.toggle());
      $('#tm-reset-btn').addEventListener('click', () => timer.reset());

      window.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;
        if (e.ctrlKey || e.metaKey) {
          if (e.key.toLowerCase() === 'z') {
            e.preventDefault();
            e.shiftKey ? board.redo() : board.undo();
          }
          if (e.key.toLowerCase() === 'y') {
            e.preventDefault();
            board.redo();
          }
          if (e.key.toLowerCase() === 's') {
            e.preventDefault();
            board.downloadPNG();
          }
        }
        if (e.key === 'Escape') {
          $$('.modal-backdrop:not(.hidden)').forEach(el => el.classList.add('hidden'));
          $('#dlg-qr-zoom').classList.add('hidden');
        }
      });
    });
  </script>
</body>

</html>