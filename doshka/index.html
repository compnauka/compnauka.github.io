<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Онлайн-дошка</title>

  <!-- Tailwind CSS (для продакшну краще зібрати локально) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome (іконки) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

  <!-- QRCode.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <meta name="theme-color" content="#111827" />
  <style>
    :root { --toolbar-bg: rgba(255,255,255,.92) }
    html, body { height:100%; }
    body { font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; background:#fff; color:#111827; }
    #whiteboard { touch-action: none; } img { padding: 20px; background: white;; }
    .tool-btn { transition: transform .15s ease, box-shadow .15s ease, background-color .15s ease; }
    .tool-btn[aria-pressed="true"] { transform: scale(1.05); box-shadow: 0 0 0 2px rgba(59,130,246,.6) }
    .color-btn[aria-current="true"] { box-shadow: 0 0 0 3px rgba(59,130,246,.5); transform: scale(1.08) }
    .modal-backdrop { background: rgba(0,0,0,.6); backdrop-filter: blur(2px) }
    .toolbar-responsive { max-width: 95vw; }
    @media (max-width:1100px){ .toolbar-responsive { flex-wrap: wrap; gap:.4rem; padding:.4rem } .separator { display:none } }
    [data-dialog] { outline: none }
  </style>
</head>
<body class="h-screen w-screen overflow-hidden">
  <div id="app" class="relative w-full h-full">

    <!-- Полотно -->
    <canvas id="whiteboard" class="w-full h-full bg-white cursor-crosshair select-none" aria-label="Полотно для малювання" role="img"></canvas>

    <!-- Верхній оверлей таймера -->
    <div id="timer-overlay" class="hidden absolute top-4 right-4 z-30 bg-gray-900/90 text-white text-xl font-mono px-4 py-2 rounded-lg shadow-lg">
      <span id="timer-display">00:00</span>
    </div>

    <!-- Панель інструментів -->
    <div class="toolbar-responsive absolute bottom-4 left-1/2 -translate-x-1/2 z-40 bg-white/90 backdrop-blur-sm p-3 rounded-xl shadow-lg border border-gray-200 flex items-center gap-2">
      <!-- Інструменти -->
      <div class="flex items-center gap-2">
        <button id="btn-pen" class="tool-btn p-2.5 rounded-lg bg-gray-100 hover:bg-blue-100"
                type="button" data-tool="pen" aria-label="Перо (P)" aria-pressed="true" title="Перо (P)">
          <i class="fa-solid fa-pen text-lg"></i>
        </button>
        <button id="btn-eraser" class="tool-btn p-2.5 rounded-lg bg-gray-100 hover:bg-blue-100"
                type="button" data-tool="eraser" aria-label="Гумка (E)" aria-pressed="false" title="Гумка (E)">
          <i class="fa-solid fa-eraser text-lg"></i>
        </button>
      </div>

      <div class="separator w-px h-6 bg-gray-300"></div>

      <!-- Колір -->
      <div class="flex items-center gap-2">
        <input id="color-picker" type="color" value="#000000" class="w-8 h-8 p-0.5 bg-gray-100 rounded-lg cursor-pointer border border-gray-200" aria-label="Вибір кольору">
        <div class="flex items-center gap-1">
          <button class="color-btn w-6 h-6 rounded-md border bg-black" data-color="#000000" aria-label="Чорний" aria-current="true" title="Чорний"></button>
          <button class="color-btn w-6 h-6 rounded-md border bg-red-500" data-color="#ef4444" aria-label="Червоний" title="Червоний"></button>
          <button class="color-btn w-6 h-6 rounded-md border bg-green-500" data-color="#22c55e" aria-label="Зелений" title="Зелений"></button>
          <button class="color-btn w-6 h-6 rounded-md border bg-blue-500" data-color="#3b82f6" aria-label="Синій" title="Синій"></button>
        </div>
      </div>

      <!-- Розмір -->
      <div class="flex items-center gap-2 bg-gray-100 px-2 py-1.5 rounded-lg">
        <i class="fa-regular fa-circle text-sm"></i>
        <input id="size-range" type="range" min="1" max="50" value="5" class="w-24 cursor-pointer" aria-label="Розмір штриха">
        <span id="size-value" class="text-xs text-gray-600 min-w-[1.5ch] font-mono">5</span>
      </div>

      <div class="separator w-px h-6 bg-gray-300"></div>

      <!-- Undo/Redo/Clear -->
      <div class="flex items-center gap-1">
        <button id="btn-undo" class="tool-btn p-2.5 rounded-lg bg-gray-100 hover:bg-blue-100 disabled:opacity-50" type="button" title="Скасувати (Ctrl/Cmd+Z)" disabled>
          <i class="fa-solid fa-rotate-left text-lg"></i>
        </button>
        <button id="btn-redo" class="tool-btn p-2.5 rounded-lg bg-gray-100 hover:bg-blue-100 disabled:opacity-50" type="button" title="Повторити (Ctrl/Cmd+Shift+Z)" disabled>
          <i class="fa-solid fa-rotate-right text-lg"></i>
        </button>
        <button id="btn-clear" class="tool-btn p-2.5 rounded-lg bg-red-100 hover:bg-red-200 text-red-600" type="button" title="Очистити полотно">
          <i class="fa-regular fa-trash-can text-lg"></i>
        </button>
      </div>

      <div class="separator w-px h-6 bg-gray-300"></div>

      <!-- Save / QR / Timer -->
      <div class="flex items-center gap-1">
        <button id="btn-save" class="tool-btn p-2.5 rounded-lg bg-green-100 hover:bg-green-200 text-green-700" type="button" title="Зберегти як PNG (Ctrl/Cmd+S)">
          <i class="fa-solid fa-download text-lg"></i>
        </button>
        <button id="btn-qr" class="tool-btn p-2.5 rounded-lg bg-purple-100 hover:bg-purple-200 text-purple-700" type="button" title="Згенерувати QR-код">
          <i class="fa-solid fa-qrcode text-lg"></i>
        </button>
        <button id="btn-timer" class="tool-btn p-2.5 rounded-lg bg-yellow-100 hover:bg-yellow-200 text-yellow-700" type="button" title="Таймер">
          <i class="fa-regular fa-clock text-lg"></i>
        </button>
      </div>
    </div>

    <!-- Діалог: підтвердження очищення -->
    <div id="dlg-clear" class="hidden fixed inset-0 z-50 grid place-items-center modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="clear-title" data-dialog>
      <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm mx-4">
        <h2 id="clear-title" class="text-lg font-semibold text-gray-900 mb-2">Очистити полотно</h2>
        <p class="text-sm text-gray-600 mb-6">Ви впевнені, що хочете все стерти? Цю дію неможливо скасувати.</p>
        <div class="flex justify-end gap-2">
          <button data-clear-cancel class="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200">Скасувати</button>
          <button data-clear-ok class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Очистити</button>
        </div>
      </div>
    </div>

    <!-- Діалог: QR генератор -->
    <div id="dlg-qr" class="hidden fixed inset-0 z-50 grid place-items-center modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="qr-title" data-dialog>
      <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md mx-4">
        <div class="flex items-center justify-between mb-4">
          <h2 id="qr-title" class="text-lg font-semibold text-gray-900">Згенерувати QR-код</h2>
          <button data-qr-close class="text-gray-400 hover:text-gray-600 text-xl p-1 hover:bg-gray-100 rounded-full" aria-label="Закрити">×</button>
        </div>
        <div class="space-y-4">
          <input id="qr-url" type="url" placeholder="https://example.com" class="w-full px-3 py-2.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
          <button id="qr-generate" class="w-full px-4 py-2.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Згенерувати</button>
          <div id="qr-box" class="flex justify-center items-center p-6 bg-gray-50 rounded-lg min-h-[200px]">
            <p class="text-gray-500 text-center">Введіть URL для створення QR-коду. Клікніть по QR, щоб відкрити його великим.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Перегляд QR (повноекранний) -->
    <div id="qr-viewer" class="hidden fixed inset-0 z-50 bg-black/80 grid place-items-center" role="dialog" aria-modal="true" aria-label="Перегляд QR-коду" data-dialog>
      <button data-qrviewer-close class="absolute top-4 right-6 text-white text-4xl font-light hover:opacity-75" aria-label="Закрити">×</button>
      <div id="qr-viewer-content" class="flex items-center justify-center w-full h-full p-8">
        <!-- великий QR підставляється скриптом -->
      </div>
    </div>

    <!-- Діалог: Таймер -->
    <div id="dlg-timer" class="hidden fixed inset-0 z-50 grid place-items-center modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="timer-title" data-dialog>
      <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm mx-4">
        <div class="flex items-center justify-between mb-4">
          <h2 id="timer-title" class="text-lg font-semibold text-gray-900">Налаштування таймера</h2>
          <button data-timer-close class="text-gray-400 hover:text-gray-600 text-xl p-1 hover:bg-gray-100 rounded-full" aria-label="Закрити">×</button>
        </div>
        <div class="flex items-center justify-center gap-2 my-6">
          <input id="tm-min" type="number" class="w-16 p-2 text-center text-xl border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" value="5" min="0" max="99">
          <span class="text-xl font-semibold text-gray-500">:</span>
          <input id="tm-sec" type="number" class="w-16 p-2 text-center text-xl border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" value="0" min="0" max="59">
        </div>
        <div class="flex gap-2">
          <button id="tm-start" class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">Старт</button>
          <button id="tm-pause" class="flex-1 px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 hidden">Пауза</button>
          <button id="tm-reset" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Скинути</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --------- Утиліти ----------
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    function clamp(n, min, max){ return Math.min(max, Math.max(min, n)); }

    // Фокус-менеджмент для діалогів
    function openDialog(el, opener){
      el.classList.remove('hidden');
      el.dataset.openerId = opener?.id || '';
      const focusables = $$('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])', el);
      const first = focusables[0]; (first||el).focus();
      function onKey(e){
        if(e.key === 'Escape'){ closeDialog(el); }
        if(e.key === 'Tab' && focusables.length){
          const idx = focusables.indexOf(document.activeElement);
          let next = idx + (e.shiftKey?-1:1);
          if(next<0){ next = focusables.length-1; e.preventDefault(); }
          if(next>=focusables.length){ next = 0; e.preventDefault(); }
          focusables[next].focus();
        }
      }
      el._trap = onKey;
      document.addEventListener('keydown', onKey);
    }
    function closeDialog(el){
      el.classList.add('hidden');
      document.removeEventListener('keydown', el._trap);
      const opener = el.dataset.openerId && document.getElementById(el.dataset.openerId);
      if(opener) opener.focus();
    }

    // --------- Малювання ----------
    class Whiteboard {
      constructor(canvas){
        this.canvas = canvas;
        // alpha:true за замовчуванням — потрібно для коректної гумки (destination-out)
        this.ctx = canvas.getContext('2d', { desynchronized: true });
        this.dpr = Math.max(1, window.devicePixelRatio || 1);

        this.tool = 'pen';
        this.color = '#000000';
        this.size = 5;

        this.strokes = [];      // [{tool,color,size,points:[{x,y},...]}]
        this.redoStack = [];

        this.isDrawing = false;
        this.currentStroke = null;

        this.resizeObserver = new ResizeObserver(() => this.resize());
        this.resizeObserver.observe(this.canvas);

        this.resize();
        this.bindPointerEvents();
      }

      setTool(t){ this.tool = t; }
      setColor(c){ this.color = c; }
      setSize(s){ this.size = clamp(Number(s)||1, 1, 50); }

      resize(){
        const {clientWidth:w, clientHeight:h} = this.canvas;
        const needW = Math.max(1, Math.floor(w * this.dpr));
        const needH = Math.max(1, Math.floor(h * this.dpr));
        if(this.canvas.width !== needW || this.canvas.height !== needH){
          this.canvas.width = needW;
          this.canvas.height = needH;
          const ctx = this.ctx;
          ctx.setTransform(1,0,0,1,0,0);
          ctx.scale(this.dpr, this.dpr);
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';
          this.redraw();
        }
      }

      clear(){
        const ctx = this.ctx;
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,this.canvas.width,this.canvas.height); // прозорий фон
        ctx.restore();
      }

      redraw(){
        this.clear();
        for(const stroke of this.strokes){
          this.drawStroke(stroke);
        }
      }

      drawStroke(stroke){
        const ctx = this.ctx;
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = stroke.size;
        if(stroke.tool === 'eraser'){
          ctx.globalCompositeOperation = 'destination-out';
          ctx.strokeStyle = '#000'; // колір неважливий
        }else{
          ctx.globalCompositeOperation = 'source-over';
          ctx.strokeStyle = stroke.color;
        }

        const pts = stroke.points;
        if(pts.length === 1){
          const p = pts[0];
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
        }else{
          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for(let i=1;i<pts.length;i++){
            ctx.lineTo(pts[i].x, pts[i].y);
          }
          ctx.stroke();
        }
        ctx.restore();
      }

      bindPointerEvents(){
        const el = this.canvas;
        el.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          el.setPointerCapture(e.pointerId);
          const p = this._pos(e);
          this.isDrawing = true;
          this.currentStroke = { tool:this.tool, color:this.color, size:this.size, points:[p] };
          this.drawStroke(this.currentStroke);
        });

        el.addEventListener('pointermove', (e) => {
          if(!this.isDrawing) return;
          const p = this._pos(e);
          const pts = this.currentStroke.points;
          const prev = pts[pts.length-1];
          const dx = p.x - prev.x, dy = p.y - prev.y;
          if((dx*dx + dy*dy) < 0.5*0.5) return; // прорідження точок
          pts.push(p);
          this.drawStroke({ ...this.currentStroke, points:[prev, p] });
        });

        const end = (e)=>{
          if(!this.isDrawing) return;
          try{ el.releasePointerCapture(e.pointerId); }catch{}
          this.isDrawing = false;
          if(this.currentStroke?.points?.length){
            this.strokes.push(this.currentStroke);
            this.redoStack.length = 0;
          }
          this.currentStroke = null;
          this.updateUndoRedo?.();
        };

        el.addEventListener('pointerup', end);
        el.addEventListener('pointercancel', end);
        window.addEventListener('pointerup', end); // якщо відпустили поза канвасом
      }

      _pos(e){
        const r = this.canvas.getBoundingClientRect();
        return { x: (e.clientX - r.left), y: (e.clientY - r.top) };
      }

      undo(){
        if(!this.strokes.length) return;
        this.redoStack.push(this.strokes.pop());
        this.redraw();
        this.updateUndoRedo?.();
      }
      redo(){
        if(!this.redoStack.length) return;
        this.strokes.push(this.redoStack.pop());
        this.redraw();
        this.updateUndoRedo?.();
      }

      exportPNG(){
        // Експорт з білим фоном, щоб «стерті» ділянки не були прозорими у PNG
        const src = this.canvas;
        const out = document.createElement('canvas');
        out.width = src.width;
        out.height = src.height;
        const octx = out.getContext('2d');
        octx.fillStyle = '#FFFFFF';
        octx.fillRect(0,0,out.width,out.height);
        octx.drawImage(src, 0, 0);
        const link = document.createElement('a');
        link.download = `whiteboard-${Date.now()}.png`;
        link.href = out.toDataURL('image/png');
        link.click();
      }
    }

    // --------- Таймер ----------
    class SimpleTimer {
      constructor({overlay, display, dlg, btnStart, btnPause, btnReset, inputMin, inputSec}){
        this.overlay = overlay;
        this.display = display;
        this.dlg = dlg;
        this.btnStart = btnStart;
        this.btnPause = btnPause;
        this.btnReset = btnReset;
        this.inputMin = inputMin;
        this.inputSec = inputSec;

        this.remaining = 0;
        this.interval = null;
        this.paused = false;

        this.ctx = null;
        this.bind();
        this.render();
      }
      bind(){
        this.btnStart.addEventListener('click', ()=>this.start());
        this.btnPause.addEventListener('click', ()=>this.togglePause());
        this.btnReset.addEventListener('click', ()=>this.reset());
      }
      start(){
        if(this.interval) return;
        if(!this.paused){
          const m = Math.max(0, parseInt(this.inputMin.value)||0);
          const s = clamp(parseInt(this.inputSec.value)||0, 0, 59);
          this.remaining = m*60 + s;
        }
        if(this.remaining<=0) return;
        closeDialog(this.dlg);
        this.overlay.classList.remove('hidden');
        this.paused = false;
        this.btnStart.classList.add('hidden');
        this.btnPause.classList.remove('hidden');
        this.interval = setInterval(()=>this.tick(), 1000);
        this.render();
      }
      togglePause(){
        if(!this.interval){
          this.paused = false;
          this.start();
          this.btnPause.textContent = 'Пауза';
        }else{
          clearInterval(this.interval);
          this.interval = null;
          this.paused = true;
          this.btnPause.textContent = 'Продовжити';
        }
      }
      reset(){
        clearInterval(this.interval);
        this.interval = null;
        this.paused = false;
        this.remaining = 0;
        this.inputMin.value = 5; this.inputSec.value = 0;
        this.overlay.classList.add('hidden');
        this.btnStart.classList.remove('hidden');
        this.btnPause.classList.add('hidden');
        this.btnPause.textContent = 'Пауза';
        this.render();
      }
      tick(){
        if(this.remaining>0){
          this.remaining--;
          this.render();
        }else{
          clearInterval(this.interval);
          this.interval = null;
          this.render();
          this.beep();
          setTimeout(()=>this.reset(), 4000);
        }
      }
      render(){
        const m = String(Math.floor(this.remaining/60)).padStart(2,'0');
        const s = String(this.remaining%60).padStart(2,'0');
        this.display.textContent = `${m}:${s}`;
      }
      beep(){
        try{
          this.ctx = this.ctx || new (window.AudioContext||window.webkitAudioContext)();
          const freqs = [261.63, 329.63, 392.00, 523.25]; // C4 E4 G4 C5
          let t = this.ctx.currentTime;
          for(const f of freqs){
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.type = 'sine';
            o.frequency.value = f;
            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.2, t+0.01);
            g.gain.exponentialRampToValueAtTime(0.0001, t+0.25);
            o.connect(g).connect(this.ctx.destination);
            o.start(t);
            o.stop(t+0.26);
            t += 0.28;
          }
        }catch{}
      }
    }

    // --------- Головний застосунок ----------
    (function(){
      const canvas = document.getElementById('whiteboard');
      const board = new Whiteboard(canvas);

      // Кнопки / елементи інтерфейсу
      const btnPen = document.getElementById('btn-pen');
      const btnEraser = document.getElementById('btn-eraser');
      const colorPicker = document.getElementById('color-picker');
      const colorBtns = $$('.color-btn');
      const sizeRange = document.getElementById('size-range');
      const sizeValue = document.getElementById('size-value');

      const btnUndo = document.getElementById('btn-undo');
      const btnRedo = document.getElementById('btn-redo');
      const btnClear = document.getElementById('btn-clear');
      const btnSave = document.getElementById('btn-save');
      const btnQR = document.getElementById('btn-qr');
      const btnTimer = document.getElementById('btn-timer');

      // Діалоги
      const dlgClear = document.getElementById('dlg-clear');
      const clearOk = $('[data-clear-ok]', dlgClear);
      const clearCancel = $('[data-clear-cancel]', dlgClear);

      const dlgQR = document.getElementById('dlg-qr');
      const qrUrl = document.getElementById('qr-url');
      const qrBox = document.getElementById('qr-box');
      const qrGenerate = document.getElementById('qr-generate');

      const qrViewer = document.getElementById('qr-viewer');
      const qrViewerContent = document.getElementById('qr-viewer-content');

      // Таймер (оголошуємо ОДИН раз і більше не перевизначаємо)
      const dlgTimer = document.getElementById('dlg-timer');
      const timerOverlay = document.getElementById('timer-overlay');
      const timerDisplay = document.getElementById('timer-display');
      const tmStart = document.getElementById('tm-start');
      const tmPause = document.getElementById('tm-pause');
      const tmReset = document.getElementById('tm-reset');
      const tmMin = document.getElementById('tm-min');
      const tmSec = document.getElementById('tm-sec');

      const timer = new SimpleTimer({
        overlay: timerOverlay,
        display: timerDisplay,
        dlg: dlgTimer,
        btnStart: tmStart, btnPause: tmPause, btnReset: tmReset,
        inputMin: tmMin, inputSec: tmSec
      });

      // останній текст QR для великого рендера
      let lastQRText = null;

      // Undo/Redo state
      board.updateUndoRedo = function(){
        btnUndo.disabled = this.strokes.length === 0;
        btnRedo.disabled = this.redoStack.length === 0;
      };
      board.updateUndoRedo();

      // Інструменти
      function setTool(t){
        board.setTool(t);
        btnPen.setAttribute('aria-pressed', t==='pen');
        btnEraser.setAttribute('aria-pressed', t==='eraser');
        canvas.style.cursor = 'crosshair';
      }
      btnPen.addEventListener('click', ()=>setTool('pen'));
      btnEraser.addEventListener('click', ()=>setTool('eraser'));

      // Колір / Розмір
      function setColor(c){
        board.setColor(c);
        colorPicker.value = c;
        colorBtns.forEach(b=>b.setAttribute('aria-current', b.dataset.color===c ? 'true':'false'));
        if(board.tool==='eraser') setTool('pen');
      }
      colorPicker.addEventListener('input', (e)=>setColor(e.target.value));
      colorBtns.forEach(b=>b.addEventListener('click', ()=>setColor(b.dataset.color)));
      function setSize(v){ board.setSize(v); sizeValue.textContent = board.size; }
      sizeRange.addEventListener('input', (e)=>setSize(e.target.value));
      setSize(sizeRange.value);

      // Undo/Redo/Clear/Save
      btnUndo.addEventListener('click', ()=>board.undo());
      btnRedo.addEventListener('click', ()=>board.redo());
      btnSave.addEventListener('click', ()=>board.exportPNG());

      btnClear.addEventListener('click', (e)=>openDialog(dlgClear, e.currentTarget));
      clearCancel.addEventListener('click', ()=>closeDialog(dlgClear));
      clearOk.addEventListener('click', ()=>{
        board.strokes.length = 0;
        board.redoStack.length = 0;
        board.redraw();
        board.updateUndoRedo();
        closeDialog(dlgClear);
      });

      // QR генератор
      btnQR.addEventListener('click', (e)=>openDialog(dlgQR, e.currentTarget));
      $('[data-qr-close]', dlgQR).addEventListener('click', ()=>closeDialog(dlgQR));
      qrGenerate.addEventListener('click', ()=>{
        if(typeof QRCode === 'undefined'){
          qrBox.innerHTML = '<p class="text-red-600 text-center">Бібліотека QRCode не завантажилась. Перевірте підключення.</p>';
          return;
        }
        const raw = qrUrl.value.trim();
        if(!raw){ qrUrl.focus(); return; }
        let url = raw;
        try{
          const u = new URL(raw, window.location.href);
          if(!/^https?:$/i.test(u.protocol)) u.protocol = 'https:';
          url = u.href;
        }catch{
          url = 'https://' + raw.replace(/^\/+/, '');
        }
        lastQRText = url;
        qrBox.innerHTML = '';
        new QRCode(qrBox, { text: url, width: 220, height: 220, correctLevel: QRCode.CorrectLevel.M });
      });

      // Клік по QR → великий QR (~85% висоти екрану)
      qrBox.addEventListener('click', (e)=>{
        const targetSize = Math.min(
          Math.floor(window.innerHeight * 0.85),
          Math.floor(window.innerWidth * 0.95)
        );
        qrViewerContent.innerHTML = '';
        if (typeof QRCode !== 'undefined' && lastQRText) {
          new QRCode(qrViewerContent, {
            text: lastQRText,
            width: targetSize,
            height: targetSize,
            correctLevel: QRCode.CorrectLevel.M
          });
          openDialog(qrViewer, btnQR);
          return;
        }
        // фолбек на існуючий елемент
        let dataUrl = null;
        const img = e.target.closest('img');
        const cvs = e.target.closest('canvas');
        if (img) dataUrl = img.src;
        if (!dataUrl && cvs) dataUrl = cvs.toDataURL('image/png');
        if (dataUrl) {
          qrViewerContent.innerHTML =
            `<img src="${dataUrl}" alt="QR код"
                  style="height:85vh;max-width:95vw;width:auto;image-rendering:pixelated;object-fit:contain;">`;
          openDialog(qrViewer, btnQR);
        }
      });
      $('[data-qrviewer-close]', qrViewer).addEventListener('click', ()=>{
        qrViewerContent.innerHTML = '';
        closeDialog(qrViewer);
      });

      // Таймер діалог
      btnTimer.addEventListener('click', (e)=>openDialog(dlgTimer, e.currentTarget));
      $('[data-timer-close]', dlgTimer).addEventListener('click', ()=>closeDialog(dlgTimer));

      // Гарячі клавіші
      document.addEventListener('keydown', (e)=>{
        if(['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
        const ctrl = e.ctrlKey || e.metaKey;
        if(e.key === 'p' || e.key === 'P') { e.preventDefault(); setTool('pen'); }
        else if(e.key === 'e' || e.key === 'E') { e.preventDefault(); setTool('eraser'); }
        else if(ctrl && e.key.toLowerCase() === 'z' && !e.shiftKey) { e.preventDefault(); board.undo(); }
        else if((ctrl && e.key.toLowerCase() === 'z' && e.shiftKey) || (ctrl && e.key.toLowerCase() === 'y')) { e.preventDefault(); board.redo(); }
        else if(ctrl && e.key.toLowerCase() === 's') { e.preventDefault(); board.exportPNG(); }
        else if(e.key === 'Escape') {
          [dlgClear, dlgQR, qrViewer, dlgTimer].forEach(dlg => {
            if(!dlg.classList.contains('hidden')) closeDialog(dlg);
          });
        }
      });

      // Підтримка жестів на мобільних
      let lastTouchEnd = 0;
      canvas.addEventListener('touchend', (e)=>{
        const now = Date.now();
        if(now - lastTouchEnd <= 300){ e.preventDefault(); }
        lastTouchEnd = now;
      }, false);
      document.addEventListener('gesturestart', (e) => e.preventDefault());
      document.addEventListener('gesturechange', (e) => e.preventDefault());
      document.addEventListener('gestureend', (e) => e.preventDefault());

      // Ініціалізація
      setTool('pen');
      setColor('#000000');
      console.log('Онлайн-дошка готова до роботи! 🎨');
    })();
  </script>
</body>
</html>
