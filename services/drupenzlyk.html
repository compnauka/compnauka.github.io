<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Друпензлик: Творчий Зошит</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --line-height: 40px;
            --paper-padding-top: 60px;
            --paper-color: #ffffff;
            --line-color: #ddd6fe;
            --primary-color: #7c3aed;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: #f5f3ff;
            overscroll-behavior: none;
            height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        #paper-wrapper {
            background-color: #f5f3ff;
            background-image: radial-gradient(#ddd6fe 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #paper-container {
            position: relative;
            background: var(--paper-color);
            box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.15);
            width: 100%;
            max-width: 900px;
            height: 100%;
            margin: 0 auto;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 0 0 16px 16px;
        }

        .pattern-lines {
            background-image: linear-gradient(var(--line-color) 1px, transparent 1px);
            background-size: 100% var(--line-height);
            background-attachment: local;
            background-position: 0 calc(var(--paper-padding-top) - 8px);
        }
        
        #text-layer {
            position: absolute;
            inset: 0;
            z-index: 10;
            padding: var(--paper-padding-top) 3rem 0 3rem;
            line-height: var(--line-height);
            font-size: 22px;
            outline: none;
            overflow-y: auto;
            color: #334155;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        #drawing-layer {
            position: absolute;
            inset: 0;
            z-index: 20;
            width: 100%;
            height: 100%;
            pointer-events: none;
            touch-action: none;
        }

        body[data-mode="text"] #drawing-layer { pointer-events: none; }
        body[data-mode="text"] #text-layer { pointer-events: auto; cursor: text; }
        
        body[data-mode="draw"] #drawing-layer { pointer-events: auto; cursor: crosshair; }
        body[data-mode="draw"] #text-layer { pointer-events: none; user-select: none; }

        .tool-btn {
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .tool-btn:active { transform: scale(0.95); }
        .tool-btn.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
        }

        .btn-group {
            display: flex;
            background: #f1f5f9;
            padding: 4px;
            border-radius: 12px;
            gap: 4px;
        }
        .icon-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            color: #64748b;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 1rem;
        }
        .icon-btn:hover { background: #e2e8f0; color: #0f172a; }
        .icon-btn.active { background: white; color: var(--primary-color); box-shadow: 0 1px 2px rgba(0,0,0,0.1); }

        .color-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 0 0 1px #cbd5e1;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-dot.active { transform: scale(1.2); box-shadow: 0 0 0 2px var(--primary-color); border-color: white; }

        #text-layer::-webkit-scrollbar { width: 8px; }
        #text-layer::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 4px; }
        #text-layer::-webkit-scrollbar-track { margin-top: 20px; margin-bottom: 20px; }

        .toolbar-section { display: none; width: 100%; justify-content: center; align-items: center; gap: 1rem; }
        .toolbar-section.visible { display: flex; animation: fadeIn 0.3s ease-out; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body data-mode="text">

    <header class="h-16 bg-white shadow-sm flex items-center justify-between px-4 z-50 no-print flex-shrink-0 border-b border-violet-100">
        <div class="flex items-center gap-3 select-none">
            <div class="w-10 h-10 bg-gradient-to-br from-violet-500 to-purple-600 rounded-xl flex items-center justify-center text-white shadow-lg transform -rotate-2">
                <i class="fas fa-paint-brush"></i>
            </div>
            <h1 class="font-extrabold text-xl text-violet-800 tracking-tight">Друпензлик</h1>
        </div>
        
        <div class="flex bg-slate-100 p-1.5 rounded-2xl gap-1 shadow-inner">
            <button onclick="App.setMode('text')" class="tool-btn active px-5 py-2 rounded-xl flex items-center gap-2 text-slate-600" id="btn-mode-text">
                <i class="fas fa-font"></i> <span class="hidden sm:inline text-sm font-bold">Писати</span>
            </button>
            <button onclick="App.setMode('draw')" class="tool-btn px-5 py-2 rounded-xl flex items-center gap-2 text-slate-600" id="btn-mode-draw">
                <i class="fas fa-pencil-alt"></i> <span class="hidden sm:inline text-sm font-bold">Малювати</span>
            </button>
        </div>

        <div class="flex gap-2">
            <button onclick="UI.toggleModal(true)" class="w-10 h-10 flex items-center justify-center text-red-500 bg-red-50 hover:bg-red-100 rounded-xl transition" title="Очистити">
                <i class="fas fa-trash-alt"></i>
            </button>
            <button onclick="App.saveAsImage()" class="w-auto px-4 h-10 flex items-center justify-center text-white bg-violet-500 hover:bg-violet-600 rounded-xl transition shadow-md gap-2" title="Зберегти як картинку">
                <i class="fas fa-download"></i> <span class="hidden md:inline font-bold text-sm">Зберегти</span>
            </button>
        </div>
    </header>

    <div class="bg-white border-b border-slate-200 z-40 no-print min-h-[64px] flex items-center justify-center px-4 overflow-x-auto shadow-sm">
        
        <div id="text-toolbar" class="toolbar-section visible">
            <div class="btn-group">
                <button onclick="TextTool.format('bold')" class="icon-btn" title="Жирний"><i class="fas fa-bold"></i></button>
                <button onclick="TextTool.format('italic')" class="icon-btn" title="Курсив"><i class="fas fa-italic"></i></button>
                <button onclick="TextTool.format('underline')" class="icon-btn" title="Підкреслений"><i class="fas fa-underline"></i></button>
            </div>

            <div class="btn-group">
                <button onclick="TextTool.format('justifyLeft')" class="icon-btn" title="Ліворуч"><i class="fas fa-align-left"></i></button>
                <button onclick="TextTool.format('justifyCenter')" class="icon-btn" title="Центр"><i class="fas fa-align-center"></i></button>
                <button onclick="TextTool.format('justifyRight')" class="icon-btn" title="Праворуч"><i class="fas fa-align-right"></i></button>
            </div>

            <div class="w-px h-8 bg-slate-200"></div>

            <div class="btn-group">
                <button onclick="TextTool.setSize(3)" class="icon-btn font-bold text-sm" id="fs-3" title="Малий">М</button>
                <button onclick="TextTool.setSize(5)" class="icon-btn font-bold text-lg" id="fs-5" title="Середній">С</button>
                <button onclick="TextTool.setSize(7)" class="icon-btn font-bold text-xl" id="fs-7" title="Великий">В</button>
            </div>
            
            <div class="w-px h-8 bg-slate-200"></div>

            <div class="flex gap-2 items-center" id="text-colors"></div>
        </div>

        <div id="draw-toolbar" class="toolbar-section">
            <button onclick="DrawTool.undo()" class="w-10 h-10 bg-slate-100 text-slate-600 rounded-xl hover:bg-slate-200 flex items-center justify-center transition" title="Скасувати">
                <i class="fas fa-undo"></i>
            </button>

            <div class="w-px h-8 bg-slate-200"></div>

            <div class="btn-group">
                <button onclick="DrawTool.setTool('brush')" class="icon-btn active" id="tool-brush" title="Пензель"><i class="fas fa-paint-brush"></i></button>
                <button onclick="DrawTool.setTool('eraser')" class="icon-btn" id="tool-eraser" title="Гумка"><i class="fas fa-eraser"></i></button>
            </div>

            <div class="flex items-center gap-2 bg-slate-50 px-3 py-1.5 rounded-xl border border-slate-200">
                <i class="fas fa-circle text-[6px] text-slate-400"></i>
                <input type="range" id="brushSize" min="2" max="30" value="5" oninput="DrawTool.updateSize(this.value)" class="w-24 accent-violet-600 h-2 bg-slate-200 rounded-lg cursor-pointer">
                <i class="fas fa-circle text-lg text-slate-400"></i>
            </div>

            <div class="w-px h-8 bg-slate-200"></div>

            <div class="flex gap-2 items-center" id="brush-colors"></div>
        </div>
    </div>

    <div id="paper-wrapper" class="flex-1 overflow-hidden flex justify-center py-2 px-2 md:py-4">
        <div id="paper-container" class="pattern-lines bg-white">
            <div id="text-layer" contenteditable="true" spellcheck="false" aria-label="Текстове поле"></div>
            <canvas id="drawing-layer" aria-label="Полотно для малювання"></canvas>
        </div>
    </div>

    <div id="clear-modal" class="fixed inset-0 bg-slate-900/60 z-[100] hidden flex items-center justify-center backdrop-blur-sm opacity-0 transition-opacity duration-300">
        <div class="bg-white p-6 rounded-2xl shadow-2xl max-w-sm w-full transform scale-95 transition-transform">
            <h3 class="text-xl font-bold text-slate-800 mb-4 text-center">Що хочеш стерти?</h3>
            <div class="space-y-3">
                <button onclick="App.clear('canvas')" class="w-full py-3 bg-violet-50 text-violet-700 rounded-xl font-bold hover:bg-violet-100 transition flex items-center justify-center gap-2">
                    <i class="fas fa-palette"></i> Тільки малюнок
                </button>
                <button onclick="App.clear('text')" class="w-full py-3 bg-orange-50 text-orange-700 rounded-xl font-bold hover:bg-orange-100 transition flex items-center justify-center gap-2">
                    <i class="fas fa-font"></i> Тільки текст
                </button>
                <button onclick="App.clear('all')" class="w-full py-3 bg-red-500 text-white rounded-xl font-bold hover:bg-red-600 transition flex items-center justify-center gap-2 shadow-md">
                    <i class="fas fa-trash"></i> Все разом
                </button>
            </div>
            <button onclick="UI.toggleModal(false)" class="w-full mt-5 text-slate-400 text-sm hover:text-slate-600 font-semibold">Ні, я передумав</button>
        </div>
    </div>

    <div id="loading-overlay" class="fixed inset-0 bg-white/90 z-[200] hidden flex-col items-center justify-center">
        <div class="animate-spin rounded-full h-12 w-12 border-4 border-violet-200 border-t-violet-600 mb-4"></div>
        <p class="text-violet-800 font-bold animate-pulse">Зберігаємо твій шедевр...</p>
    </div>

<script>
    const Config = {
        colors: ['#1e293b', '#ef4444', '#f97316', '#eab308', '#22c55e', '#06b6d4', '#3b82f6', '#a855f7', '#ec4899'],
        defaultBrushColor: '#1e293b',
        defaultBrushSize: 5
    };

    const State = {
        mode: 'text',
        brush: { tool: 'brush', color: Config.defaultBrushColor, size: Config.defaultBrushSize },
        history: [],
        historyStep: -1
    };

    // --- NEW: Selection manager to keep caret & selection ---
    const SelectionManager = {
        savedRange: null,
        save() {
            const sel = window.getSelection();
            if (!sel || sel.rangeCount === 0) return;
            const range = sel.getRangeAt(0);
            if (!UI.els.textLayer.contains(range.commonAncestorContainer)) return;
            this.savedRange = range.cloneRange();
        },
        restore() {
            if (!this.savedRange) return;
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(this.savedRange);
        }
    };
    
    const UI = {
        els: {
            textLayer: document.getElementById('text-layer'),
            canvas: document.getElementById('drawing-layer'),
            paper: document.getElementById('paper-container'),
            modal: document.getElementById('clear-modal'),
            loader: document.getElementById('loading-overlay')
        },

        init() {
            this.renderPalette('text-colors', (c) => TextTool.setColor(c));
            this.renderPalette('brush-colors', (c) => DrawTool.setColor(c));
            
            document.getElementById('fs-5').classList.add('active');
            
            this.resizeCanvas();
            window.addEventListener('resize', this.debounce(() => this.resizeCanvas(), 200));

            // слухаємо зміну виділення в тексті
            ['mouseup', 'keyup', 'touchend'].forEach(ev => {
                this.els.textLayer.addEventListener(ev, () => SelectionManager.save());
            });
        },

        renderPalette(id, callback) {
            const container = document.getElementById(id);
            container.innerHTML = '';
            Config.colors.forEach((color, i) => {
                const dot = document.createElement('div');
                dot.className = `color-dot ${i === 0 ? 'active' : ''}`;
                dot.style.backgroundColor = color;
                dot.onclick = () => {
                    container.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
                    dot.classList.add('active');
                    callback(color);
                };
                container.appendChild(dot);
            });
        },

        toggleModal(show) {
            const cl = this.els.modal.classList;
            if (show) {
                cl.remove('hidden');
                setTimeout(() => cl.remove('opacity-0'), 10);
            } else {
                cl.add('opacity-0');
                setTimeout(() => cl.add('hidden'), 300);
            }
        },

        resizeCanvas() {
            const { canvas, paper } = this.els;
            const temp = document.createElement('canvas');
            temp.width = canvas.width; temp.height = canvas.height;
            const tctx = temp.getContext('2d');
            if (canvas.width > 0) tctx.drawImage(canvas, 0, 0);

            canvas.width = paper.clientWidth;
            canvas.height = paper.clientHeight;

            const ctx = canvas.getContext('2d');
            if (temp.width > 0) ctx.drawImage(temp, 0, 0);
        },

        debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }
    };

    const DrawTool = {
        ctx: null,
        isDrawing: false,
        lastPos: { x: 0, y: 0 },

        init() {
            this.ctx = UI.els.canvas.getContext('2d', { willReadFrequently: true });
            
            const c = UI.els.canvas;
            c.addEventListener('mousedown', this.start.bind(this));
            window.addEventListener('mousemove', this.move.bind(this));
            window.addEventListener('mouseup', this.end.bind(this));
            
            c.addEventListener('touchstart', this.start.bind(this), { passive: false });
            window.addEventListener('touchmove', this.move.bind(this), { passive: false });
            window.addEventListener('touchend', this.end.bind(this));
        },

        start(e) {
            if (State.mode !== 'draw') return;
            this.isDrawing = true;
            this.lastPos = this.getPos(e);
            this.draw(e);
        },

        move(e) {
            if (!this.isDrawing || State.mode !== 'draw') return;
            if (e.type === 'touchmove') e.preventDefault();
            this.draw(e);
        },

        end() {
            if (this.isDrawing) {
                this.isDrawing = false;
                this.ctx.beginPath();
                App.pushHistory();
                Storage.save();
            }
        },

        draw(e) {
            const pos = this.getPos(e);
            const ctx = this.ctx;

            ctx.beginPath();
            ctx.moveTo(this.lastPos.x, this.lastPos.y);
            ctx.lineTo(pos.x, pos.y);
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (State.brush.tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = State.brush.size * 3;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = State.brush.color;
                ctx.lineWidth = State.brush.size;
            }
            
            ctx.stroke();
            this.lastPos = pos;
        },

        getPos(e) {
            const rect = UI.els.canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        },

        setTool(tool) {
            State.brush.tool = tool;
            document.getElementById('tool-brush').classList.toggle('active', tool === 'brush');
            document.getElementById('tool-eraser').classList.toggle('active', tool === 'eraser');
        },

        setColor(color) {
            State.brush.color = color;
        },

        updateSize(val) {
            State.brush.size = val;
        },

        undo() {
            if (State.historyStep > 0) {
                State.historyStep--;
                this.restore(State.history[State.historyStep]);
            } else if (State.historyStep === 0) {
                State.historyStep = -1;
                this.ctx.clearRect(0, 0, UI.els.canvas.width, UI.els.canvas.height);
                Storage.save();
            }
        },

        restore(dataUrl) {
            const img = new Image();
            img.onload = () => {
                this.ctx.clearRect(0, 0, UI.els.canvas.width, UI.els.canvas.height);
                this.ctx.drawImage(img, 0, 0);
                Storage.save();
            };
            img.src = dataUrl;
        }
    };

    const TextTool = {
        currentColor: Config.colors[0],

        // застосувати будь-який формат (жирний, вирівнювання, колір)
        format(cmd, val = null) {
            UI.els.textLayer.focus();
            SelectionManager.restore();

            if (cmd === 'foreColor') {
                document.execCommand('styleWithCSS', false, true);
                document.execCommand('foreColor', false, val || this.currentColor);
            } else {
                document.execCommand(cmd, false, val);
            }

            SelectionManager.save();
            Storage.save();
        },

        // окремо вибір кольору з палітри
        setColor(color) {
            this.currentColor = color;
            this.format('foreColor', color);
        },
        
        setSize(size) {
            UI.els.textLayer.focus();
            SelectionManager.restore();

            document.execCommand('styleWithCSS', false, true);
            document.execCommand('fontSize', false, size);
            
            [3, 5, 7].forEach(s => {
                const btn = document.getElementById(`fs-${s}`);
                btn.classList.toggle('active', s === size);
                btn.classList.toggle('bg-violet-100', s === size);
            });
            
            SelectionManager.save();
            Storage.save();
        }
    };

    const Storage = {
        save() {
            localStorage.setItem('dp_text', UI.els.textLayer.innerHTML);
            localStorage.setItem('dp_img', UI.els.canvas.toDataURL());
        },
        
        load() {
            const txt = localStorage.getItem('dp_text');
            const img = localStorage.getItem('dp_img');
            
            if (txt) UI.els.textLayer.innerHTML = txt;
            if (img) {
                App.pushHistory();
                const image = new Image();
                image.onload = () => {
                    DrawTool.ctx.drawImage(image, 0, 0);
                    State.history.push(img);
                    State.historyStep = 0;
                };
                image.src = img;
            } else {
                App.pushHistory();
            }
        }
    };

    const App = {
        init() {
            UI.init();
            DrawTool.init();
            Storage.load();
            this.setMode('text');
        },

        setMode(mode) {
            State.mode = mode;
            document.body.setAttribute('data-mode', mode);

            const btnText = document.getElementById('btn-mode-text');
            const btnDraw = document.getElementById('btn-mode-draw');
            
            btnText.className = `tool-btn px-5 py-2 rounded-xl flex items-center gap-2 ${mode === 'text' ? 'active text-white' : 'text-slate-600'}`;
            btnDraw.className = `tool-btn px-5 py-2 rounded-xl flex items-center gap-2 ${mode === 'draw' ? 'active text-white' : 'text-slate-600'}`;

            const textToolbar = document.getElementById('text-toolbar');
            const drawToolbar = document.getElementById('draw-toolbar');

            if (mode === 'text') {
                textToolbar.classList.add('visible');
                drawToolbar.classList.remove('visible');
                UI.els.textLayer.focus();
            } else {
                drawToolbar.classList.add('visible');
                textToolbar.classList.remove('visible');
            }
        },

        pushHistory() {
            State.historyStep++;
            State.history = State.history.slice(0, State.historyStep);
            State.history.push(UI.els.canvas.toDataURL());
        },

        clear(type) {
            if (type === 'canvas' || type === 'all') {
                DrawTool.ctx.clearRect(0, 0, UI.els.canvas.width, UI.els.canvas.height);
                this.pushHistory();
            }
            if (type === 'text' || type === 'all') {
                UI.els.textLayer.innerHTML = '';
            }
            Storage.save();
            UI.toggleModal(false);
        },

        async saveAsImage() {
            const loader = UI.els.loader;
            loader.classList.remove('hidden');
            loader.classList.add('flex');

            try {
                await new Promise(r => setTimeout(r, 100));

                const canvasResult = await html2canvas(UI.els.paper, {
                    scale: 2, 
                    useCORS: true,
                    backgroundColor: '#ffffff'
                });

                const link = document.createElement('a');
                link.download = `drupenzlyk-${Date.now()}.png`;
                link.href = canvasResult.toDataURL('image/png');
                link.click();
            } catch (err) {
                console.error(err);
                alert('Помилка збереження. Спробуй ще раз!');
            } finally {
                loader.classList.add('hidden');
                loader.classList.remove('flex');
            }
        }
    };

    window.onload = () => App.init();

</script>
</body>
</html>
